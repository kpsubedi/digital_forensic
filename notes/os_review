
Difference between library call and system call

Library Call:
------------
If possible make a library call, it is just a cost of calling subroutine 

System Call:
------------
Trap into the operating system 
10 times more expensive 

Does this things potentially affect any other processes?
If we need to coordiate with other processes it needs to be a system call.
If it is only going to affect current process it doesnot need to be
a system call.

For Example
-----------
String concatination doesnot need to be system call. There is no other processes in the system care you
are concatinating strings together. It is done using library call.

If we read data from file we need to coordinate to process potentially 
writing data to the same file. In particular, We want to ensure automacity of system call.
There is a porcess attempting to write to the file and you are trying to read the same part 
of the same file. The promise the system has to make is either you see before the file
write started or you see after the write completed. You donot see the file half written.

****************
What is a "FILE"?
Ans: 
How files are stored?
Ans: 
Typically, disk contains multiple partitions. Each partition contains it's own file system. 
We can say file systems are located inside of a disk partition. The parition is usually 
organized into 512-bytes per sector. When the partition is formatted as Ext3, 
consecutive sectors will be grouped into blocks, whose size can range from 
1024 to 4096 bytes (1K to 4K). The blocks are grouped together into block groups,
whose size will be tens of thousands of blocks. 

Each file has data stored in three major locations:
1. Blocks
2. Inodes
3. Directory Entries

A file content is stored in blocks, which are allocated for exclusive use of the file. 
A file is allocated as many blocks as it needs. Ideally, the file will be allocated consecutive blocks, but 
this is not always possible.

The metadata for the file is stored in an I-node structure, which is located in 
an inode table at the beginning of a block group. There are a finite number of inodes 
and each is assigned to a block group. File metadata includes the temporal data 
such as the last modified, last accessed, last changed, and deleted times. 
Metadata also includes the file size, user ID, group ID, permissions, and block 
addresses where the file content is stored.

The addresses of the first 12 blocks are saved in the inode and additional addresses are 
stored externally in blocks, called indirect blocks. If the file requires many blocks and not 
all of the addresses can fit into one indirect block, a double indirect block is used whose 
address is given in the inode. The double indirect block contains addresses of single 
indirect blocks, which contains addresses of blocks with file content. 
There is also a triple indirect address in the inode that adds one more layer of pointers.

The file's name is stored in a directory entry structure (man 2 getdents), which is located in a block allocated to 
the file's parent directory. 


Hard-Drives
===========

PATA (Parallel ATA) connector
SATA (Serial ATA) connector
Drive can be IDE but connectors can be PATA or SATA

CD/DVD 
-------
used same cable but using slightly different protocols
PATAPI or SATAPI

PI = Packet Interface


PCI bus
=======
used I/O Port


DMA
====
- Alternate method of device communication
- Much faster but much harder and requires a lot more setup code

BIOS 
- Basic Input/Output System
ROM
- Read-only Memory (Commonly writable these days)

When power on ==> CPU gets on

- CPU needs to run code 

"where's the code?!"

- Hard-wired to load code from the BIOS ROM at startup.


BIOS and Booting
----------------
Power Off
- Start from the processor of being switched off with the computer switched off there is no power in the system
except for one component that one component is the system clock which is powered by a small battery on the 
motherboard and keep track of the real world time this component however is not really relevant to what we are 
looking 

Power On
- When you press the power button a variety of things happen but the main option is that the processors of powers on
and start trying to execute 
- Remember when a processor which on it must always have some instructions to execute 
- Very few instructions are pre-build into hardware there are very good reasons for this 
 - the main one being software can engineered changed and updated much more easily later 






































































