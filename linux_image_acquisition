
Acquire entire hard drive or just get one partition

Get data from usb stick

#dd if=/dev/sdb1 of=usb_stick.dd 

Syntax of dd
------------
dd if=<source_file> of=<destination_file> [options]

if=<source_file> : This is a source file from where we want to copy data and "if" stands for "input file".
of=<destination_file> : This is a destination file where we want to write data and "of" stands for "output file".

[options] : size of block, how fast, what format etc.



Use Cases:

1. Hard Drive Clone

#dd if=/dev/sda of=/dev/sdb

2. Backup of partition
#dd if=/deb/sdb2 of=~/hd_backup.img

3. Restore from backup image
#dd if=~/hd_backup.img of=/dev/sda4

4. Alternative to cp
#dd if=/etc/passwd of=/root/passwd_backup

5. Wipe or Delete content
#dd if=/dev/zero of=/dev/sdb

6. Wipe out with randomized data
#dd if=/dev/random of=/dev/sda

for i in {1..20};do dd if=/dev/random of=/dev/sda; done

7. Create virtual swap space in linux

#dd if=/dev/zero of=/swapfile bs=1024 count=300

bs=1024 === 1 KB
Default block size is 512 bytes. 

8. Create ISO files

#dd if=/dev/sr0 of=/home/$USER/cd_file.iso bs=2048 conv=sync

There can be challenges when using dd to forensically image a disk. 
If read erros occur in the middle of an acquisition, dd will abort with an "Input/Output Error". 
Address this issue by adding conv=noerror, which will force dd to skip over the unreadable 
block and continue. The problem with skipping over unreadable blocks is that the sector 
offset on the destination file changes for filesystem blocks on the rest of the disk, 
causing the rest of the filesystem on the disk to appear corrupted. 

To illustrate, consider the pages of a book. Suppose page 99 is ripped out. If the table of conents points to 
a chapter starting at page 200, it's still possible to find it. The book's page numbers are intact, 
even with the missing page. But this is not the case when sector 99 is ripped out of a disk image (due to
a read error). The rest of the sectors are renumberred, and the filesystem's "table of contents" will point 
to the wrong blocks after sector 99.

The "sync" parameter corrects this by padding the unreadable output block with zeros, essentially creating 
a "fake" sector or block (full of zeros) to represent the missing one. The rest of the disk image will then 
have the correct sector numbers (offsets) expected by the filesystem it contains.

# dd if=/dev/sda of=image.raw conv=noerror,sync



